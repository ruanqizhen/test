# 装载和运行子VI

## 静态与动态装载子VI

一般情况下，一个VI被打开时，它所有的子VI也都会同时被装入内存。这种把子VI载入内存的方式称为静态装载。对于一些小型程序而言，这种做法没有任何不妥。但是对于大型的、有成百上千个子VI组成的程序来说，在主VI打开的同时，装入所有的子VI，这种做法将带来两个主要的弊病。一是占用内存过大，二是程序启动速度过慢。

在大型程序中，总会有一些运行分支上的子VI使用频率较低。按照使用的频率可以把子VI分成三个级别：经常被使用的（比如，启动主程序十次，某个子VI至少有三四次会被运行到）；偶尔被使用的（比如，启动主程序一百次，某个子VI只有不到十次会被运行到）；几乎从来不被使用的（比如，启动主程序上百次，某个子VI才会有一次被运行到）。那些偶尔被使用的以及几乎从来不被使用的VI，如果也随同主VI一起在启动时被装入内存，很可能程序在一段较长的运行期间内都不会被程序用到。但它们却与经常被用到的子VI一样，占用了宝贵的内存和程序启动时间。

解决这个问题的思路其实很简单------就是在程序启动时，暂时不载入这些子VI，直到需要运行到它们的时候再将其装入内存。这样一来，在程序未用到它们时，就不会为它们分配内存。同时，程序启动时不用装载那么多子VI，启动速度也可以提高。实际上，装载这些子VI所占用的时间被分散到程序运行中去了。

另外，对于几乎从来不被使用的子VI，在运行结束后，可以立即把它卸载出内存以节约内存。但是比较常用的VI应该一直存放在内存中，因为把VI卸载再装入内存是比较耗时的。

在子VI的右键菜单中选择"调用设置..."，即可在"VI调用配置"对话框中指定何时把此子VI加载入内存。其缺省值是设置为"与调用方同时加载"。比如，对于图 4.18中的程序，"任务B"这个子VI偶尔被调用，就可以把它设置为"首次调用时加载并保留"（图 6.17）。于是，程序在第一次运行"任务B.vi"时才会把它装载进内存。如果设置为"每次调用时重新加载"，那么这个子VI每次运行结束后，都会被卸载出内存（图 6.18）。

![](images/image404.png)

图 .17子VI的调用设置对话框

![](images/image405.png)

图 .18设置子VI为首次调用时加载并保留

子VI被设置为"首次调用时加载并保留"或"每次调用时重新加载"之后，实际上是由"通过引用节点调用"这个节点来调用的。所以它们的图标外观看上去有了一些改变，不再是普通子VI的模样，而是类似于一个"通过引用节点调用"节点（该节点位于"编程->应用程序控制"函数子选板）。这两种设置的图标略有差别：设置为"首次调用时加载并保留"时，图标的左上角有一个沙漏图案，而设置为"每次调用时重新加载"则没有。

使用"通过引用节点调用"节点只能在编程时控制子VI何时装入内存。还有一种更灵活控制VI装载的方式，就是使用"打开VI引用"函数来打开一个VI的引用。

如果一个VI尚不在内存中，那么在打开它的引用的同时，就会把它装入内存。如果VI已经在内存中，是不会被重新装入的。"打开VI引用"函数需要提供一个"VI路径"输入，假如这个VI不在内存中，那么需要提供VI的全路径，方可打开它的引用；如果VI已经在内存中，则只需要输入这个VI的名称，就可以得到它的引用了。

使用"关闭引用"函数可以关闭一个打开了的VI引用。若这个VI只是被"打开VI引用"函数装入内存的，并且每次打开产生的引用都已经被关闭，那么这个VI会被卸载出内存。

## 动态调用VI

一个普通的子VI，或是上一段提到的"通过引用节点调用"的子VI，其何时被调用都是在编辑时就指定了的。但有时候，程序在运行过程中才能够决定把哪个子VI装入内存运行。这个动态把子VI装入内存运行的过程称为动态调用子VI。

运行动态调用子VI的主要步骤一般有三步：动态打开一个VI，运行VI，关闭VI的引用。

有两种方法可以完成这个功能。一是使用"通过引用节点调用"节点。上一段在讲述通过子VI的"调用设置"选项来设定VI的装载方式时，提到过这个节点。我们还可以采用另外一种方法，即先把这个节点放到程序框图上，再把一个动态打开的VI引用传递给这个节点的"引用"输入，就可以动态打开并运行这个VI。拖放到程序框图上的这个节点与通过"调用设置"选项获得的节点的图标也是有细微区别的，前者的上方对应输入输出引用端口处，各有一个小小的象征"引用"的图案（图 6.19）。

![](images/image406.png)

图 .19四种子VI调用节点在外观上的差别

![](images/image407.png)

图 .20动态调用（通过引用节点调用）

"通过引用节点调用"只能传入有类型说明符的VI引用。所以，在使用"打开VI引用"函数时，要为其指定"类型说明符"（图 6.20）。"类型说明符"用于表明动态打开的VI的连线板模式，以及每个参数的数据类型。这样，在"通过引用节点调用"运行这个VI时，才可以为其输入输出适合的参数。指定"类型说明符"的方法是：右键点击"打开VI引用"函数的"类型说明符VI引用句柄（仅用于类型）"参数，为其创建一个常量；然后右键点击新创建的常量，在右键菜单中选择"选择VI服务器类->浏览"，选择一个具有与动态调用VI的连线板模式以及数据类型完全相同的VI。于是，"通过引用节点调用"节点内显示的子VI会以连线板的方式显示出来，它可以运行任何一个具有这种类型连线板的VI；而输入"打开VI引用"节点的路径，则用来指定特定的某个VI。

另一种方式是通过调用节点调用VI的"运行VI"方法。使用这种方法不需要指定VI的类型说明符，但与被调用的VI之间传递输入输出参数就比较麻烦（图 6.21）。

![](images/image408.png)

图 .21动态调用（通过运行VI方法）

设置输入参数时，需要在运行VI前，使用VI的"控件值->设置"方法，设置与输入参数对应的控件的值；返回输出参数时，需要在VI运行结束后，通过"控件值->获取"方法得到参数对应的控件的值。

"运行VI"方法有两个输入参数，用于设置运行的方式。

"Wait Until Done" 参数的默认值是"真"。"Wait Until Done"为"真"时，程序执行到此，立即开始运行被调用的子VI。一直等子VI运行结束，当前VI才继续执行"运行VI"方法之后的后续代码。这与普通子VI以及使用"通过引用节点调用"子VI的行为是一致的。"Wait Until Done"如果设置为"假"，则在被调用的子VI开始运行的同时，主VI也继续运行后续的代码。

程序往往有这样的需求：主VI在一个线程内运行，要求子VI在另一线程内并行独立运行。选用此种动态调用方式就能满足此要求。在第4.5.3节中我们曾经提到，对循环事件结构中耗时代码处理的最佳方案是，让耗时代码在另一独立线程中调用运行，而不影响主程序继续处理后续的事件。其实现方法，就是把耗时代码单独做成一个子VI，然后以不等待的方式动态调用它。

用"打开VI引用"函数打开的引用必须被关掉，否则，VI被装入内存，却从来不被卸载出内存，就会引起内存泄漏。Auto Dispose Ref参数用于决定由谁来关闭动态运行VI的引用：是通过"关闭引用"函数来卸载子VI呢，还是待子VI运行结束后，自动卸载出内存。若它的值为"假"，则必须在子VI运行结束后，使用"关闭引用"函数关闭其引用；若值为"真"，则不应该再使用关闭引用"函数。其默认值为"假"。

通过"运行VI"方法动态调用的子VI，可以再使用"停止VI"方法来终止它的运行。

## 带界面的子线程

编程中，有时候会遇到这种需求：程序有一个主界面，主界面VI需要多次调用同一个子VI，子VI同时运行多份，并显示出多个子界面窗口。例如，子VI提供了对一个阀门进行监控的界面，而主程序需要同时监控多个相同的阀门。对于这样的程序该如何实现呢？

若需要子VI打开多份实例，子VI必须是可重入的。所以第一步要把子VI设置为可重入。但仅仅如此处理还不够。主程序运行到子 VI处，把子VI打开后，会一直等待下去，直到子VI运行结束，主VI才继续执行后续的代码。主VI既然已经停在这里了，自然不可能再继续去打开其它子 VI。

解决的办法是在调用子VI的地方，改为动态调用，并且不等待子VI运行结束（参见图6.22）。这样一来，主程序运行到此处，调用运行子VI后，将立即继续执行主VI的后续代码，就又可以去调用其它的子VI了。

需要注意的是，由于子VI是可重入的，必须给"打开VI引用"函数设置一个值为"8"的"选项"参数。

![](images/image409.png)\
图6.22 动态运行可重入VI的一个实例

## 插件结构

回过头再看一看图 4.18中的程序，它虽然允许用户在程序运行时可以选择执行哪些任务，但是仍然不够灵活。程序代码决定了它最多只能运行4个任务：A、B、C、D。如果用户有了新的需求，又新编写了一个任务E子VI，必须修改主程序才能把新任务添加进去。

其实，我们可以把程序设计成更加灵活的"框架-插件"式结构。测试程序主体作为一个框架，每个测试任务作为一个插件。若增加了新的需求，不必改动框架程序，只需编写出新的插件，即可被框架加载进来以供使用。

框架式程序的核心是通过动态调用，让插件VI运行起来的。在设计插件式程序时，首先要确定插件的规范。它包括：插件VI命名或者存放位置的规范，以使得框架程序可以正确地找到插件；插件的参数接口规范，可以使框架程序为每个插件传递正确的参数。

比如图 6.22中的程序采用的规范是：在子文件夹"插件"内的文件都被认为是一个插件，若有新的插件，直接放入这个文件夹即可；每个插件都采用![](images/image410.png)样式的连线板，以采用同样的方式为每个插件传递参数。至于试验的顺序，可以在命名插件文件名时，让其第一个字母按序排列即可。

![](images/image411.png)

图 .22框架插件式程序范例

## 后台任务

在一些应用程序中，常常包含某些并不需要与用户交互的任务。这些任务通常在默默地执行着，完全不打扰用户的其它工作。这样的任务叫做后台任务。与之相反，前台任务是用户看得到的。

比如，一个文本编辑软件，前台执行的是那些帮助用户进行编辑文字的任务。如果这个软件做得好做得完美，它一定具有自动保存文件的功能。这样，万一系统突然崩溃之后，不至于让那些用户已进行的、尚未手工保存的改动都前功尽弃。自动保存这个功能一般都作为后台任务，它在执行时，不会打扰用户的其它正常操作。LabVIEW也具有自动保存的功能，即使程序崩溃后，重新打开LabVIEW，还可以恢复崩溃前的程序。后台任务的应用还有很多。

LabVIEW也可以通过动态调用的方法来实现后台任务。下面举一个简单例程。

图 6.26是一个界面VI，用于与用户交互。这个VI也就是前台VI。在这个VI上有一个控件的显示数值由后台程序来控制，它与界面上其它控件的行为互不影响。

![](images/image417.png)

图 .26前台VI的界面

后台程序通过控件的引用不断改变控件的值（图 6.27）。这样，在用户看来，该控件就会一直在不停地转动。

![](images/image418.png)

图 .27后台程序

前台VI动态调用了后台任务VI，让后台任务与前台程序并行运行在两个不同的线程（图 6.28、图 6.29）。这样，后台任务的运行独立于前台VI，两者互不干扰。

![](images/image419.png)

图 .28前台程序中把后台任务调用起来的代码

![](images/image420.png)

图 .29前台程序中终止后台任务运行的代码

基于循环事件结构的界面程序，不适合在其某一事件处理分支中运行一个耗时较长的任务。如果同时需要相应界面事件，并运行一个耗时较长的任务，可以把耗时任务当作一个后台任务来调用。

## 启动画面

大型LabVIEW程序启动的时候可能要花费一段时间，在速度低、内存小的计算机上，更是如此。因为程序必须在它所有的子VI都被装入内存之后才能执行，而把大量的子VI装入内存是需要花费时间的，如果在这段时间里，用户感觉不到显示界面有任何变化，就可能误认为是程序出错或者死机了，从而做出一些错误的操作。一个设计友好的程序应该是，在启动程序的时候立刻显示给用户一个启动画面。启动画面主要应该包括一个提示界面，告诉用户，程序正在装载以及装载的进度。并在此期间把所有的子VI装入内存，然后再启动程序的主界面。

在程序显示启动画面的这个阶段，待子VI全部装入内存后，启动画面VI再动态调用主VI，使之运行起来，并显示主VI界面。之后，启动画面自行关闭，主程序界面则取而代之。

启动画面的程序代码如图 6.30所示：

![](images/image421.png)

图 .30启动画面VI的代码

启动画面的程序代码主要分为三个部分：把程序子VI装入内存，运行程序主VI，关闭启动画面。

只要使用"打开VI引用"函数打开这些子VI的引用，就可以把它们装入内存。但是，这里需要程序员制定一个策略，让启动画面VI可以得到所有的子VI。一个简单的办法是把所有的子VI放在某一文件夹下，比如文件夹"subVIs"。启动画面VI得到这个文件夹下所有的VI，然后一一打开它们的引用。在一个一个打开子VI的同时，根据子VI的总数量和已打开子VI的数量计算出进度条的位置。

运行主VI采用动态调用的方法，首先打开主VI的引用，然后调用"运行VI"方法使其运行。与后台任务不同，程序主VI的界面需要显示给用户。所以，还需要设置主程序VI的"前面板窗口->打开"属性使其界面显示出来。在主VI运行起来之后，就可以把刚刚打开的所有子VI的引用都关闭掉了。因为，打开的主程序也需要用到这些子VI，所以这时候关闭它们的引用，并不会导致它们被移出内存。

在主VI运行起来之后，启动画面的使命也就完成了，应当让位给主程序了。这时就可以结束启动画面了。启动画面程序在此调用"前面板窗口->关闭"方法，把启动画面界面关闭。启动画面程序全部完成，启动程序终止。

## 异步调用

LabVIEW 2011 中增加了一个新的函数"开始异步调用"。这个函数可以简化运行前文提到的实现动态调用VI、开启后台任务等功能的代码的复杂度。这个新函数位于函数选板"编程->应用程序控制"里（图6.31）。

![](images/image422.png)\
图6.31 "应用程序控制"函数选板

假设要编写这样一个程序，它的界面有一个仪表盘外加两个控制按钮（图6.32）。\
![image](images/image423.png)\
图6.32 仪表盘外加两个控制按钮的界面

当Play按钮按下时，让仪表盘指针旋转。当Stop按下时程序退出。表盘指针旋转时，每隔10毫秒挪动一下位置，每两秒钟转一周，旋转5圈即10秒后指针停止旋转。维持表盘转动是一个持续的任务，它不能够阻塞程序的其它任务，比如对Stop按钮的响应。

为此，需要安排一个独立的线程来维持表盘的持续转动，这个线程需要有一个子VI。这个子VI有两个输入参数，分别是表盘和Stop按钮的引用（图6.33）。 \
![image](images/image424.png)\
图 6.33 维持表盘转动任务VI的输入参数

每隔10毫秒挪动一下表盘指针的位置，每两秒钟指针绕表盘转一周，10秒后程序停止。VI的程序代码如图6.43所示。

[ ![image](images/image425.png)](http://ruanqizhen.files.wordpress.com/2011/12/image4.png)\
图 6.34 维持表盘指针转动任务VI的程序框图1

[ ![image](images/image426.png)](http://ruanqizhen.files.wordpress.com/2011/12/image5.png)\
图 6.35 维持表盘指针转动任务2

维持表盘转动的VI同时检测主程序中Stop按钮是否被按下，如果按下就立刻停止运行（图6.35）。

在LabVIEW2011之前，实现主程序功能的唯一方法是使用VI的"运行"方法节点，把"维持表盘转动VI"动态调用运行起来，其程序框图如图6.36所示。

![image](images/image427.png)\
图 6.36 采用动态调用方法的程序框图

在这段代码最不尽人意的地方在于，运行子VI之前先要通过VI的"设置控件值"方法为子VI传递参数。这种方法不但编写复杂，安全性也低。首先，它是通过控件名来找到需要传递参数的控件的，LabVIEW无法在编译时检查参数名字是否正确。子VI中的控件若是修改了名字，程序编译时不会发现问题，但运行时就会出错。其次，它无法检查需要传递的参数的数据类型，即使传递的是一个错误类型的数据，在编译时也发现不了错误。

使用"开始异步调用"函数，这段程序可以被简化成图6.37中的代码。

![image](images/image428.png)\
图 6.37 采用开始异步调用方法的程序框图

需要注意的是，在使用"开始异步调用"函数前，打开VI引用的时候，一定要传递一个0×80的数值给"打开VI引用"函数。

"开始异步调用"函数的使用方法与"通过引用调用"十分类似，这里就不赘述了。它们的主要区别在于"通过引用调用"是同步调用的，主程序会停下来，直到被它调用的子VI运行结束；而 "开始异步调用"函数是异步的，把子VI启动起来后，主VI并不等待，仍然继续运行后续程序。

"开始异步调用"函数在功能上，与"Run VI"方法中把Wait Until Done赋值False是相同的。区别在于前者更方便参数传递，以及使代码更简洁易懂。

在"开始异步调用"函数的同一函数选板上，还有一个"等待异步调用"，它用于获取从被调用的子VI的返回数据。与"开始异步调用"函数相比，"等待异步调用"函数的实际用途有限，并不常见。

图 6.36和图 6.37中的程序，都采用了本书6.2.2节所介绍的"静态VI引用"节点来得到一个VI的引用。他们之间的不同在于图6.37中的"静态VI引用"节点带有一个五角星，它表示这是一个具有严格类型的VI引用。选取"静态VI引用"节点右键菜单中的"严格类型的VI引用"项就可以把它设置为严格类型。严格类型的VI引用只能用来表示特定连线板类型的VI。由于"开始异步调用"函数需要VI连线板的信息，因此，它只能传入使用严格类型的VI引用。

在LabVIEW 2011或后续版本中，若把"严格类型的VI引用"作为属性节点和调用节点的引用输入，属性节点和调用节点上方不再简单的显示输入引用类型为"VI"，而是会显示"VI接口类型n"（n是一个数字）。
