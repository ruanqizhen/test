# 应用实例

## 管理一个类的多个对象

这是最常见的面向对象编程的应用。在程序里经常会出现需要管理多个同类型对象的情况。比如一个测试程序，可能会使用到同类型的多台仪器。那就可以把这个型号的仪器定义为一个类，每台仪器就是这个类的一个对象；它每次采集到的数据也是相同类型的，也可以把数据的模型定义成一个类，每次采集的数据是一个实例；数据需要保存在格式相同的文件中，所以可以把这种格式的文件定义为一个类，每个文件就是一个实例。

比如一个简单测试程序，需要把所有的测试数据保存在统一格式的文件中。在应用程序中需要管理多个格式相同的文件，所以可以为这种类型的文件编写一个类。

这个文件中保存有实验名称、实验时间和实验数据。因此，类的数据中应当包含这些信息（图
13.11）。

![](images/image788.png)

图 .11类的数据

这些数据是不能直接被应用程序读写的，所以还要为它们创建读写方法。使用右键菜单"新建"中的"用于数据成员访问的VI"，就可以直接创建出这些属性读写方法。

除了属性读写方法，数据文件还常常会用到以下几个方法：打开、创建、保存等。因此，这个数据文件类中也实现了这些方法。

"打开"方法用于从文件中读出数据，保存在类的数据中（图 13.12）。

![](images/image789.png)

图 .12数据文件类的打开方法

"保存"方法与"打开"方法是相反的过程。把类中的数据存入文件（图 13.13）。

![](images/image790.png)

图 .13数据文件类的保存方法

"创建"方法用于创建一个空的数据文件对象。为了演示方便，程序中还为这个数据文件类添加了一个"清空"方法，用于清空类中的所有数据。设计好的类结构如图
13.14所示。

![](images/image791.png)

图 .14数据文件类

图
13.15是使用这个类的一段演示程序，倘若需要应用到多个数据文件，程序可以在一开始就为每个文件生成一个对象。之后的程序中，就可以使用类的方法，对这些对象进行操作。使用类的方法时，和使用普通VI是一样的，把它们拖到程序框图上即可使用。

![](images/image792.png)

图 .15在应用程序中使用类

另外再举一个例子，笔者曾经在一个演示项目中使用到了一块某公司产的数据采集卡。为了编程方便，为它写了一套基于类的驱动程序。其总体结构如图
13.16所示。

![](images/image793.png)

图 .16基于类的硬件驱动程序

这个驱动程序的思路是，把所有这块硬件的设置参数（如：采样率、放大倍数等）作为类的数据（图
13.17），而用户可以调用的硬件的功能（如：初始化、读数据等）则作为类的方法。类中某些VI仅作为其它VI的子VI，不能给用户使用的，只要设为私有，就可以了。

![](images/image794.png)

图 .17硬件驱动程序类中的数据

图
13.18是使用这一驱动程序的一个示例程序。例子只演示了使用一块硬件卡的情况，如果程序需要用到多块相同的硬件卡，只要用"Open"方法打开多个驱动程序类的对象就可以了。

![](images/image795.png)

图 .18使用基于面向对象的驱动程序

## 同一段代码处理多种数据类型

虽然管理多个对象是最典型的类的使用方法，但是读者可能会发现，在前面提到的这两个例子中，类并不是必需的。完全可以使用簇和LabVIEW的库达到同样的效果：簇用来保存原来类中的数据，而原本类的方法都做成库中的VI就可以了。

LabVIEW中的类可以涵盖簇的功能，这就如同C++中的类和结构有时也可通用一样。不过，使用簇加库的方式，只能实现对模块的封装，类的另外两大特性：继承和多态是没法实现的。所以类的一些更为复杂的应用，就不可能使用簇来替代了。

如果使用簇加库的方式，那么应用程序的一份代码，只能处理一种数据类型。比如，图
13.15中的示例程序，只是处理了一种格式的文件。如果使用簇来记录所有数据文件的内容也是可以的。但是，如果程序中需要使用几种不同格式的文件，即表示它们的簇的内容不同，是属于不同的数据类型的簇。一个子VI的某个参数必须是固定的，换成另外一种数据类型就不能接受了。所以若需要处理两种以上的数据类型，即便所做的工作是相同的，也必须编写两套VI。

但是，如果某个VI属于类的子VI，那么，尽管每个子类的数据类型不同，它就可以处理这个类的所有子类。这样，在应用程序中，只需编写一段代码，就可以处理多种不同类型的数据，势必会大大提高编程效率。

以一个最简单的应用为例。一个程序需要处理两种类型的数据：一个数值型，一个簇型。程序的功能是把两种类型的数据中的数值都加1。

作为演示，这个程序的代码极为简单，实际上只是调用了一个子VI。但是这个子VI却可以处理两种不同类型的数据（图
13.19）。

![](images/image796.png)

图 .19同一方法处可以处理不同数据类型

实现这一功能的方法是，把程序中使用到的两种数据类型"数值"和"簇"装箱成类。（换句话说，就是创建两个类，这两个类中的数据分别是数值类型的数据，和簇类型的数据。）再创建一个数据为空的基本类做为它们共同的父类（图
13.20）。而程序中所用到的算法，都在这个父类中实现。父类的方法是可以直接被子类使用的，每个子类数据类型不同，这样父类的算法就可以应用于多种不同的数据类型了。

![](images/image797.png)

图 .20处理不同数据类型的类的结构

多态VI也可以实现类似的功能，即根据不同类型的输入数据，选择不同的实例VI来处理这个数据。但是使用多态VI时，程序没有办法把各种不同的类型的输入数据放置在同一数据结构（比如数组）中进行存储和传递。换言之，多态VI是在编程时就根据输入数据类型的不同，为其选择了不同的实例VI进行处理。实例VI一旦选定，在程序运行过程中就不能改变了。而面向对象的编程方法则可以做到在程序运行时，用相同的方法把所有数据传给了某个子VI后，这个子VI仍然可以根据输入数据类型的不同为其分配不同的处理方法。比如，为了简化应用程序代码，在处理图
13.19中的程序时，往往使用循环结构，来减少对"加1.vi"子VI的调用次数。如图
13.21所示。

![](images/image798.png)

图 .21把不同类型的数据放在同一数据结构中

算法应该是与数据类型无关的。比如，一个排序算法既可以给数值类型的数据排序，又可以给字符串类型的数据排序。在编程实现一个算法时，也应该做到这一点。编写好一段某种算法的程序，它就应该可以方便地适用于各种类型的数据，而不必针对每种不同类型的数据再重新实现算法。

把算法和数据类型分离开来的编程方法叫做泛型编程。目前，不借助于类，是无法在LabVIEW上实现泛型编程的。了解Java泛型编程的读者对这一应用会比较容易理解，因为LabVIEW使用的这种方法和Java中泛型编程的实现方法是非常类似的。

## 递归

本书在第6.3.4节中介绍了利用动态调用实现递归的编程方法。但是使用动态调用方法编程比较繁琐，而且运行效率也比较低。实现递归调用的理想方法是，可以把一个具有递归功能的VI直接拖拽到自己的程序框图上，成为自己的子VI。然而LabVIEW
8.6以及之前的版本是不允许这样做的。幸好有一个例外，就是类的方法VI可以作为自己的子VI，进行递归调用。

比如下面的程序用类的方法实现了“[装载和运行子VI](#docs/vi_server_for_subvi):递归调用”一节中用来计算阶乘的那个Factorial.vi。新创建的类如图13.22所示，它的数据是空的，也只有一个方法，就是需要被递归调用的那个VI。

![](images/image799.png)

图 .22为实现递归调用创建的类

新的递归实现阶乘算法如下：在它的VI程序框图上调用了一个子VI，而这个子VI正是它自身（图13.23）。对比利用动态调用的实现方法（图 6.24）。这与LabVIEW2009之后的静态递归调用是类似的。

![](images/image800.png)

图 .23借助类实现递归调用

## 框架插件程序架构

本书在第6.3.3节中介绍了利用动态调用实现"框架-插件"式程序结构的编程方法。使用类也可以达到同样的效果，并且可以简化代码，并提高程序效率。

比如，某一应用程序需要把所有放在相对路径"Plugin/"下的任务都运行一遍。这就可以使用"框架-插件"式程序结构。界面及任务调度等是主程序，也就是框架；被执行的每一个任务是一个插件。编写框架程序时，有多少个插件是不确定的，每次框架程序运行起来之后，再检查"Plugin/"文件夹，凡是里面合乎定义的文件都是一个插件。

使用类来编写这种模式的程序，需要为所有的插件定义一个统一的接口，即插件接口类。这个类定义了插件的接口方法，这个方法VI在每个插件中都应该有固定的连线板模式和参数类型。这样框架程序才能以统一的标准来调用插件。接口方法VI可以多于一个。

在演示程序中，每个插件只有一个接口方法，叫做"执行.vi"。调用这个VI时，程序弹出一个对话框，上面标志着这个插件的名字。所以，在"插件接口"类只需要创建一个动态分配模板的方法。这个VI除了类输入/输出和错误输入/输出之外，不需要额外的参数。

程序中的每个插件，也是一个类。它们都继承自同一个父类"插件接口"类。每个子类都重写父类的接口方法，在这个例子中就是"执行.vi"。每个任务所完成的具体工作都在这个"执行.vi"中完成。

实现好的项目结构如图
13.24所示："插件接口"是所有插件的父类；"任务xx"是每个插件的类。它们有统一的接口方法。

![](images/image801.png)

图 .24插件们的类结构

图
13.25是其中一个任务的接口方法的实现代码，在演示程序中它只是弹出一个对话框，显示这是任务1。

![](images/image802.png)

图 .25插件接口方法的程序框图

框架程序的实现方法如图
13.26所示。它的前半部分与使用动态VI编写框架程序的方法是一样的：在固定的文件夹下，找到所有符合插件定义的文件。

程序后半部分有所不同。框架程序首先调用"编程-\>簇、类与变体-\>获取LV类默认值"VI，这个VI可以为一个类文件创建一个采用默认值的对象。由于这个VI可以应用在所有类上，所以它输出的类是所有LabVIEW类共同的祖先类"LabVIEW对象"。而需要调用的是插件接口类中的方法，所以，接下来需要使用"编程-\>簇、类与变体-\>转换为特定的类"函数，把LabVIEW对象类型转为更为特殊化的"插件接口"类。之后调用插件接口类的"执行"方法。

由于类有多态性，虽然程序框图上只是调用了插件接口类的"执行"方法，但程序实际上调用的是每个插件的特定类的执行方法。这样，执行这个演示程序，程序会顺序弹出"任务1"、"任务2"等信息。

![](images/image803.png)

图 .26框架插件结构程序的实现方法

使用类来实现框架插件结构的程序，比使用动态调用VI方法实现相同的结构要更为简单高效。

下面比较一下这两种方法各自的优缺点。

|             | 动态调用VI                               | LvClass     |
|-------------|-----------------------------------------|------------------------------------------------------------------------------------------------|
| LabVIEW版本 | LabVIEW很早的版本就具备了动态调用VI的功能。| LabVIEW 8.2开始才支持面向对象的程序设计。   |
| 开发的难度  | 相对来说比较直观易懂。 | 对于已经了解了LabVIEW面向对象编程的用户来说，做一个插件也是比较简单的。但是如果完全没接触过面向对象这个概念，还需要预先学习面向对象编程。      |
| 插件的形式  | 插件是一个单独的VI，插件所有的功能都必须在这个VI中实现。 | 插件是一个对象（类的实例）。插件对象可以拥有多个方法。一个新的插件被添加进来后，它的所有方法可以自动应用于框架程序中任何调用了插件方法的地方。 |
| 总结    | 适合简单程序       | 适合大型程序     |

表 13.1动态调用VI与LvClass实现框架插件程序架构的比较

## 使用LvClass实现链表等数据结构

LabVIEW自带的数据结构只有数组和队列。多数情况下，这两种数据结构足够开发者使用了。但是，有C++和C#语言编程经验的程序员，在编写LabVIEW程序时也常常会希望使用C++和C#编程语言中常见的数据结构，比如链表（List）、树（Tree）等。其实，在LabVIEW中也可以编程实现这些数据结构。一个比较直观易懂的编程方法是基于LabVIEW中的类和引用来实现各类数据结构。

在C++和C#语言中还常常会遇到数据容器这一个概念。数据结构和数据容器是十分相似的概念：数据结构侧重于数据的存储方式，比如按何种顺序存储数据；数据结构再加上与此结构相关的操作方法，比如添加删除数据等方法，就构成了一个数据容器。脱离了操作方法，单纯的数据结构用处非常有限。因此，本书在提到数据结构或者数据容器时，指的都是同一回事：数据结构和相关的方法。

本节，以双向链表为例，讲解一下如何在LabVIEW中实现一个数据结构。

![image](images/image804.png)\
图13.27 双向链表示意图

在双向链表中，每个节点都记录了上一个节点和下一个节点的位置。因此，在双向链表中，可以从一个节点直接跳转到它的上一个或下一个节点上去，也就是正向或反向遍历整个链表。可以直观地想到，使用LvClass就能够实现这样的节点。只要为这个节点创建一个类ListNode，并且这个类有两个成员变量，它们的类型都是ListNode的引用，分别用于指向前一个和后一个节点就可以了：

![image](images/image805.png)\
图13.28 ListNode类中的数据

这样的设计在文本编程语言中是没有问题的，但在LabVIEW中行不通。在其它编程语言中，程序运行时，才会对类的对象进行初始化。LabVIEW中，VI一打开，它的控件和常量就需要被初始化了。某个对象在初始化时，它的成员变量也要被初始化，若它的成员变量的类型还是这个类，这个初始化的过程就陷入了死锁：类需要它的成员变量先初始化；它的成员变量需要这个类先初始化。

基于同样的原因，一个类的成员变量的数据类型也不可以是这个类的子类：子类初始化需要先对它的父类进行初始化。但是，一个类的成员变量的数据类型可以是这个类的父类：父类在初始化的时候，不需要理会它的任何子类。

既然父类初始化时，不依赖于子类的初始化；而子类的对象又可以被当做父类的类型来保存，那就可以利用这一特性在LabVIEW中实现数据结构的节点了。只不过在LabVIEW实现链表的节点要多一个步骤：需要为ListNode类再定义一个父类ListNodeVirtual。这个父类不做任何实质性的工作，它仅用于保存相邻节点的引用。

![image](images/image806.png)\
图13.29 LabVIEW可以使用的ListNode类的示意图

以上两个类是针对链表节点的。双向链表本身也需要做成一个类：DoubleLinkedList类，这个类中封装有链表的属性和方法。比如它需要一个指向链表表头的引用；需要有为链表添加删除数据的方法；为遍历链表中的数据，还需要有一个迭代器......

下面的示例，实现了链表的几个简单功能。演示程序项目结构如图13.30所示。

![image](images/image807.png)\
图13.30 双向链表项目结构

ListNode的成员变量包括一个数据，和两个指向前后节点的引用。

![image](images/image808.png)\
图13.31 ListNode类的成员变量

DoubleLinkedList类的成员变量包括指向链表头节点的引用，迭代器指向的节点的引用，并记录了链表长度

![image](images/image809.png)\
图13.32 DoubleLinkedList类的成员变量

下面详细介绍一下链表中几个主要方法是如何实现的。

首先是Append after
Enumerator.vi这个方法，它是链表里最复杂的一个方法。它的输入是链表中一个新的节点，它把这个新节点添加在链表迭代器指向的那个节点的后面。

在给链表添加数据时，会遇到两种情况。第一种情况，这个链表是一个空链表，那么被添加的节点就是这个链表的首节点，链表的迭代器也应当指向这个唯一的节点。

如果设计的这个链表是一个环状链表。当链表中只有一个节点的时候，这个链表的上一个和下一个节点都是它自己（图13.33）。

![image](images/image810.png)\
图13.33 在空链表中插入一个节点

第二种情况，如果链表不是空的，就把新节点插在迭代器指向的节点的后面。具体操作如下：新节点的前一节点指向的应当是迭代器指向的那个节点；新节点的后一节点是迭代器指向节点的后一节点；迭代器指向节点的新的后一节点应当是这个新节点；原来迭代器的后一节点的前一节点也应当换成这个新的节点（这一段比较容易引起迷惑，读者可以想象在图13.27中插入一个新节点是，对箭头所作的修改。）；最后，迭代器也指向了这个新的节点。这样连续添加新节点时，它们会按照先后顺序插入链表。程序如图13.34所示。

![image](images/image811.png)\
图13.34 在非空的链表中插入一个节点

最终的演示程序还用到了其它几个方法。

Reset Enumerator.vi
负责把迭代器复位，也就是指向链表的头节点（图13.35）。

![image](images/image812.png)\
图13.35 Reset Enumerator.vi的代码

Enumerator go Next.vi 用于让迭代器向后移动一个节点（图13.36）。

![image](images/image813.png)\
图13.36 Enumerator go Next.vi的代码

Enumerator Value.vi 返回迭代器指向的那个节点（图13.37）。

![image](images/image814.png)\
图13.37 Enumerator Value.vi的代码

使用这几个方法就可以搭建出一个简单的演示程序来实现链表的功能了。图13.38是一个简单的演示程序，它分两部分：第一部分是左面那个循环，每次循环迭代就会创建出一个新的ListNode对象，它的数值是当前迭代的次数；右半部分使用链表的迭代器遍历链表中的节点。在这个演示程序中，迭代器移动次数比链表长度多了两次，因为链表是环状的，转着圈访问，链表中的头两个元素会被读出两遍。

![image](images/image815.png)\
图13.38 演示程序代码

程序运行后，data显示了迭代器每一步所指向的节点的值（图13.39）。

![image](images/image816.png)\
图13.39 演示程序运行结果

